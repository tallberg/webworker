<style>div {font-family: 'Courier New', Courier, monospace} progress{height:5px;}</style>
<div>
    <div id="out"></div>
    <progress value="0" max="1" id="progress"></progress>
    <div id="current"></div>
</div>
<script>
const out = document.getElementById('out');;
const current = document.getElementById('current');
const progress = document.getElementById('progress');

class Feeder {
    _current;  // current count for current length
    _alphabet; // given characters
    _len; // output length
    _base; // alphabet length
    _max; // nr of outputs for current length (used for stats)
    constructor(alpha){
        this._alphabet = alpha;
        this._current = 0;
        this._len = 1;
        this._base = alpha.length;
        this._max = Math.pow(this._base, this._len + 1) - 1;
    }
    _fromInt = (i) => {
        let result = '';
        let rest = 0;
        for(let pos = this._len; pos >= 0; pos--) {
            let rest = i % this._base;
            result = this._alphabet[rest] + result;
            i = ~~(i / this._base);
        }
        if(i !== 0){
            result += this._alphabet[0];
            this._current = 0;
            this._len++
            this._max = Math.pow(this._base, this._len + 1) - 1; 
        }
        return result;
    }
    next = () => {
        return this._fromInt(this._current++);
    }
    current = () => this._fromInt(this._current);
    progress = () => {
        return { 'current' : this._current, 'max': this._max, 'percent': this._current / this._max };
    }
    reset = () => this._current = 0;
}

class WorkerManager {
    _jobName;
    _generator;
    _onMessage;
    _instances = [];
    _halt = false;
    /**
     * @param {string} job Path to worker script
     * @param {number} instances Number of workers to instanciate
     * @param {any} generator Object or generator with a "next" function to seed the workers
     * @param {function} onMessageFunction Function to handle worker responses. If returns true all workers will terminate. If false, worker will be called with generator.next().
     * @param {bool} startOnCreate Should workers start directly?
     */
    constructor(job, instances = 1, generator, onMessageFunction, startOnCreate = false) {
        this._job = job;
        this._generator = generator;
        this._onMessage = onMessageFunction;
        this.spawn(instances, startOnCreate);        
    }
    spawn = (instances, post = true) => {
        console.log('spawn', instances, post);
        while (instances-- > 0) {
            const worker = this._instances[this._instances.push(new Worker(this._job)) - 1];
            worker.onmessage = (response) => {
                if(this._onMessage(response) || this._halt) {
                    this._halt = true;
                    worker.terminate();
                } else {
                    worker.postMessage(this._generator.next());
                }
            };
            if(post) {
                console.log('workwork',worker);
                worker.postMessage(this._generator.next());
            }
        }
    }
    post = () => {
        for(let instance of this._instances) {
            instance.postMessage(this._generator.next())
        }
    }
    halt = () => {
        this._halt = true;
    }
}


// const target = '2804890A4B43E24D922447DDAAAD3B2A'; //FFF
const target = '722A5443E3B3EE1B5DA271AE9F477F10'; //FFFF
// const target = '5A554D4B4CC04DFED2311CFE2AA544B2'; //FFFFF

function testResult(data) {
    const result = data[1];
    if(result !== target) { 
	    return false;
	}
	const endTime = new Date
	const plaintext = data[0];
	out.innerHTML = `<h3>${plaintext}</h3><p>${msToString(endTime - startTime)}</p>`;
	clearInterval(progressInterval);
	return true;
}

//const feeder = new Feeder('0123456789ABCDEF');
const feeder = new Feeder('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz');
const onMessage = response => testResult(response.data);
const workerManager = new WorkerManager('worker.js', 4, feeder, onMessage, true);
const startTime = new Date;

let lastVal = 0;
let progressInterval = setInterval(function(){
    const prog = feeder.progress();
    progress.value = prog.percent;
    current.innerText = feeder.current() + ' ' + 2 * (prog.current - lastVal) + '#/s';
    lastVal = prog.current;
}, 500);


function msToString(ms) {
  if (!ms) return '0';
  if (ms < 1000) return `${ms} ms`;
  if (ms < 1000 * 60) return `${Math.floor(ms / 1000)}.${ms % 1000} s`; 
  const addZero = (value) => (value < 10 ? `0${value}` : value);
  const hours = addZero(Math.floor(ms / (1000 * 60 * 60)));
  const minutes = addZero(Math.floor((ms / (1000 * 60)) % 60));
  const seconds = addZero(Math.floor((ms / 1000) % 60));
  ms = ms % 1000;
  return `${hours}:${minutes}:${seconds}.${ms}`;
}


</script>
